'''
Одним из ключевых понятий объектно-ориентированного программирования является инкапсуляция
- упаковка в целях простоты использования связанных переменных и функций в один объект (экземпляр класса).
Сокрытие данных - близкое к инкапсуляции понятие, суть которого в том, что детали реализации класса должны быть скрыты, 
и чистый стандартный интерфейс должен быть представлен тем, кто будет использовать класс.
В других языках программирования это достигается с использованием частных методов и атрибутов, 
которые закрывают доступ извне к определенным методам и атрибутам класса.
'''
'''
Условно частные методы и атрибуты оформляются с единым подчеркиванием в начале имени.
Это частные методы, которые не должны взаимодействовать со внешней частью программы. Но часто это правило условно; внешняя часть программы может получить к ним доступ.
Реальная особенность этих методов лишь в том, что from module_name import * не будет импортировать переменные, которые начинаются с единого подчеркивания.
'''
class Queue:
    def __init__(self, contents):
        self._hiddenlist = list(contents)

    def push(self, value):
        self._hiddenlist.insert(0, value)

    def pop(self):
        return self._hiddenlist.pop(-1)

    def __repr__(self):
        return "Queue({})".format(self._hiddenlist)

queue = Queue([1, 2, 3])
print(queue)
queue.push(0)
print(queue)
queue.pop()
print(queue)
print(queue._hiddenlist)
 
# Во фрагменте кода вверху атрибут _hiddenlist помечен как частный, но внешний код все же сможет получить к нему доступ. 
# Магический метод __repr__ возвращает экземпляр в виде строки.
'''
Строго частные методы и атрибуты оформляются с двойным подчеркиванием в начале имени.
Таким образом их имена искажаются, и внешняя часть программы не может получить к ним доступ.
Но это делается не для того, чтобы обеспечить их частность, а чтобы избежать ошибок, если где-либо в коде есть подклассы,
которые имеют методы или атрибуты с такими же именами.
Методы с искаженными именами все же могут быть вызваны извне, но по другим именам.
Метод __privatemethod класса Spam может быть вызван извне по имени _Spam__privatemethod.
'''

class Spam:
    __egg = 7
    def print_egg(self):
        print(self.__egg)

s = Spam()
s.print_egg()
print(s._Spam__egg)
print(s.__egg)
#Python самостоятельно защищает члены класса: автоматически включает имя класса в их имена.